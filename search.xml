<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git 笔记]]></title>
    <url>%2F2019%2F07%2F10%2F2019-07-10-git%2F</url>
    <content type="text"><![CDATA[git 分布式代码托管 分支git branch aaa // 创建分支aaa git branch -a // 查看所有分支git checkout gaia // 切换到 gaia 分支 -b 参数 创建并切换到 该分支 git pull origin gaia // 将远程 gaia 分支 fetch + merge 到当前所在分支git push -u origin master:gaia // 将本地master 分支push 到远程 gaia 分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang 笔记]]></title>
    <url>%2F2019%2F07%2F02%2F2019-07-05-Golang%2F</url>
    <content type="text"><![CDATA[golang … go envset GOOS=linux // 目标平台的操作系统 darwin, freebsd, linux, windowsset CGO_ENABLED=0 //set GOARCH=amd64 // 386, amd64, arm golang 工具go build test.go // 编译 test.gogo install // 生成包]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 笔记]]></title>
    <url>%2F2019%2F07%2F02%2F2019-07-02-Linux%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Linux 各个版本常用命令 … …red hat, centos。 ubuntu, debian debian912345678dpkg --get-selections // 查看已安装的软件apt-get update // 已安装的软件包是否有可用的更新，给出汇总报告，更新软件列表apt-get upgrade // 更新已安装的软件包，**小心使用**apt-get remove --purge yum // 彻底删除 yumapt-cache search ...apt-file search ...apt-get install ...]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx.conf]]></title>
    <url>%2F2019%2F06%2F20%2F2019-06-20-nginx.conf%2F</url>
    <content type="text"><![CDATA[nginx 轻量级，高并发，web服务器。俄罗斯 基本配置1234567891011121314151617181920212223242526# www.you.com , vhostserver &#123; # 端口号 listen 80; # 域名 server_name www.you.com; root &quot;E:/www/dist/&quot;; index index.html index.htm index.php l.php; #access_log logs/host.access.log main; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; # 解析.php的文件 location ~ \.php$ &#123; # php所在目录一直 root &quot;E:/www/you/public/&quot;; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125;&#125; 详细123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122user nobody;#启动进程,通常设置成和cpu的数量相等worker_processes 1; #全局错误日志及PID文件#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info; #pid logs/nginx.pid; #工作模式及连接数上限events &#123; #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内 # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置 # 使得并发总数小于操作系统可以打开的最大文件数目 # 其实质也就是根据主机的物理CPU和内存进行配置 # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。 # ulimit -SHn 65535 &#125; http &#123; #设定mime类型,类型由mime.type文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6].&quot;; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #设定虚拟主机配置 server &#123; #侦听80端口 listen 80; #定义使用 www.nginx.cn访问 server_name www.nginx.cn; #定义服务器的默认网站根目录位置 root html; #设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; #默认请求 location / &#123; #定义首页索引文件的名称 index index.php index.html index.htm; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #过期30天，静态文件不怎么更新，过期可以设大一点， #如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; &#125;&#125; https://blog.csdn.net/weixin_38628533/article/details/80815022]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F06%2F11%2F2019-06-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[日常数据结构整理。 线性表树]]></content>
      <categories>
        <category>struct</category>
      </categories>
      <tags>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常 Vue.js 笔记]]></title>
    <url>%2F2019%2F05%2F15%2F2019-05-15-%E6%97%A5%E5%B8%B8%20Vue.js%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前端框架。学习笔记。 npm 和 cnpm 和 项目初始化https://www.runoob.com/vue2/vue-install.html Vue 中的报错vue的eslint报错的解决方法 在config目录下的index.js文件中将useEslint: true,改为useEslint: false,即可： conf 目录index.js 详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061dev: &#123; //生成source-map与源码对应 方便调试 devtool: &apos;cheap-source-map&apos;, // 如果部署一级目录(vue-admin.com)就写 / 如果二级目录（http://david.com/vue-admin）就写 /vue-admin assetsPublicPath: &apos;/Home/&apos;, //跨域代理 proxyTable: &#123; &apos;/&apos;: &#123; target: &apos;https://26.innfotech.com/&apos;, secure: false, changeOrigin: true, pathRewrite: &#123; &apos;^/&apos;: &apos;/&apos; &#125; &#125; &#125;, // Paths assetsSubDirectory: &apos;static&apos;, // 开发 服务器配置 host: &apos;localhost&apos;, // ip port: 3030, //端口 autoOpenBrowser: true, errorOverlay: true, notifyOnErrors: false, poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- // 是否开启eslint代码检查 useEslint: false, // 是否将eslint错误显示在错误提示中 showEslintErrorsInOverlay: false, // 是否生成cssSourcemap cssSourceMap: false &#125;,build: &#123; // 生成独立的source-map devtool: &apos;source-map&apos;, // 如果部署一级目录(vue-admin.com)就写 / 如果二级目录（http://david.com/vue/ /vue/ assetsPublicPath: &apos;/Home/&apos;, // 打包输出目录 assetsRoot: path.resolve(__dirname, &apos;../../Home&apos;), // Template for index.html index: path.resolve(__dirname, &apos;../../Home/index.html&apos;), assetsSubDirectory: &apos;static&apos;, //生产环境不生成sourcemap productionSourceMap: false, // 是否开启 Gzip // 打开前 先安装： // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report || false, // `npm run build:prod --generate_report` generateAnalyzerReport: process.env.npm_config_generate_report || false &#125; 指令v-bind:class 下面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; new Vue()12345678910111213141516171819202122data: function() &#123; return &#123; msg: &apos;cursor: pointer&apos;, number: &apos;&apos;, &#125; &#125;,// 加载完后自动触发的方法 created: function() &#123; console.log(&apos;created&apos;, Date.now()); &#125;, // 计算属性 computed: &#123; number: function() &#123; return this.msg; &#125; &#125;, // 侦听器 watch: &#123; msg: function(newMsg, oldMsg) &#123; console.log(newMsg, oldMsg); &#125; &#125; 其他存储localStorage1window.localStorage.setItem(name, content); 常用的组件axios ajaxtoast 提示层 动画element-ui]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis RDB(快照) AOF(写命令)]]></title>
    <url>%2F2019%2F05%2F09%2F2019-05-09-Redis%20RDB(%E5%BF%AB%E7%85%A7)%20AOF(%E5%86%99%E5%91%BD%E4%BB%A4)%2F</url>
    <content type="text"><![CDATA[Redis是基于内存的数据库，进行读写操作时，redis都在内存中完成，然后定时的刷新到磁盘中去。RDB和AOF就是两种持久化内存中数据的方式。RDB可以将某一时刻的所有数据写入硬盘中，相当于复制了一份数据；而AOF会在redis执行写命令时，将被执行的写命令复制到磁盘中。恢复数据的时候，redis会在原有基础上依次执行AOF文件中的写命令，从而恢复数据。下面会详细的讲下RDB和AOF的原理和机制。 RDB RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。 手动保存 RDB 文件savesave命令会阻塞redis服务器的进程，直到RDB文件创建完，在该期间，redis不能处理任何的命令请求，这就是save命令最大的缺陷。bgsave与save命令不同的是，bgsave在生成RDB文件时，会派生出一个子进程，子进程负责创建RDB文件，在此期间，主进程和子进程是同时存在的，因此不会阻塞redis服务器进程。 （注：可用lastsave命令查看生成RDB文件是否成功） 自动保存 RDB 文件redis提供了使用配置文件配置的方式每隔一段时间自动执行一次bgsave命令，配置在redis.conf中123save 900 1 // 900 秒内，进行1 次保存save 300 10 // 300 秒内，进行10 次保存save 60 10000 其他配置12345dbfilename dump.rdb // RDB 文件名dir ./ // 存储位置stop-writes-on-bgsave-error yes // 当生成 RDB 文件出错时是否继续处理 Redis 写命令，默认为不处理rdbcompression yes // 是否对rdb 文件压缩rdbchecksum yes // 是否对 RDB 文件进行校验和校验 RDB 的优点:RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 RDB 的缺点:如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。 快照的运作方式当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：Redis 调用 fork() ，同时拥有父进程和子进程。子进程将数据集写入到一个临时 RDB 文件中。当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。只进行追加操作的文件（append-only file，AOF）快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。 AOF配置文件 redis.conf123appendonly yes // 是否打开AOFappendfilename &quot;appendonly.aof&quot; // AOF 文件名appendfsync everysec // 同步频率 appendfsync 可选值 (alwaysredis执行每个写命令时，都同步写入硬盘，这样会严重降低redis性能,everysec每秒执行一次，显示的在这一秒内执行的写命令同步到硬盘,no 不同步到硬盘,让操作系统来决定何时进行同步) AOF 的优点:使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 AOF 的缺点:对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。 AOF 重写:因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。 如果 AOF 文件出错了，怎么办？服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。 当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：为现有的 AOF 文件创建一个备份。使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。$ redis-check-aof –fix（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。AOF 的运作方式AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。 以下是 AOF 重写的执行步骤:Redis 执行 fork() ，现在同时拥有父进程和子进程。子进程开始将新 AOF 文件的内容写入到临时文件。对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。 RDB 和 AOF ,我应该用哪一个？一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。因为以上提到的种种原因， 未来我们可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。） 为最新的 dump.rdb 文件创建一个备份。将备份放到一个安全的地方。执行以下两条命令：redis-cli&gt; CONFIG SET appendonly yesredis-cli&gt; CONFIG SET save “”确保命令执行之后，数据库的键的数量没有改变。确保写命令会被正确地追加到 AOF 文件的末尾。步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。 备份 Redis 数据:Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 原子地用临时文件替换原来的 RDB 文件。这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 优化 (一)]]></title>
    <url>%2F2019%2F04%2F22%2F2019-04-22-Mysql%20%E4%BC%98%E5%8C%96%20(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[优化的方面 存储层：数据表”存储引擎”选取、字段类型选取、逆范式(3范式) 设计层：索引、分区/分表 架构层：分布式部署(集群) sql语句层：结果一样的情况下，要选择效率高、速度快、节省资源的sql语句执行 存储引擎 查看引擎：show engines;查看表结构：show create table table_name;查看表状态：show table status like ‘table_name’; 什么是存储引擎MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 MYISAM 每个MyISAM在磁盘上存储成三个文件。 .frm : 表结构文件 .MYD : 数据文件(mysql data) .MYI : 索引文件(mysql index) 管理非事务表，提供高速存储和检索，以及全文搜索能力。(支持物理复制、粘贴以实现数据的备份、还原操作) 数据写入顺序 数据写入时候，不会按照主键id值给予排序存储，该特点导致数据写入的速度非常快。写没有固定顺序，存也按照写的顺序存，不给考虑先后顺序。 并发性 mysiam的并发性(同时处理工作的能力)较比innodb要稍逊色因为数据表是“表锁”(innodb行锁) 压缩 如果一个myisam数据表存储的数据非常多，就会占据很大的硬盘空间，硬盘空间我们不在乎，在乎的是mysql数据库系统为了处理该数据表就需要分配更多的资源，为了节省资源，可以把这个myisam数据表给进行压缩处理。 123[root@localhost ~] pwd/usr/bin/myisampack压缩语法：myisampack 表名(绝对路径定义) 压缩后的数据表仍然可以支持查询操作,压缩后的数据表需要根据最新的数据位置把索引重新建立一次。根据压缩后的据把索引重建建立起来。 123[root@localhost ~] find / -name myisamchk/usr/bin/myisamchk重建索引语法：myisamchk -rq 表名(绝对路径定义) 压缩的数据表不能再写入数据了(尝试写入会造成数据表崩溃)，必须解压后才可以。(解压缩的同时，索引会自动重建) 1解压语法：myisamchk --unpack 表名(绝对路径定义) innodb .frm : 结构文件 .ibd : 数据/索引文件 innodb数据表不能直接的复制/粘贴文件，以便做进行备份还原，可以通过如下指令完成数据的备份和还原：存储引擎用于事务处理应用程序，具有众多特性，包括ACID事务支持，提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 12mysqldump -uroot -p密码 数据库名字 &gt; /home/xiaogang/xxx.sql [备份]mysql -uroot -p密码 数据库名字 &lt; /home/xiaogang/xxx.sql [还原] 数据写入顺序 该innodb数据表，数据的写入顺序 与 存储的顺序不一致，需要按照主键的顺序把记录摆放到对应的位置上去，速度比Myisam的要稍慢。 并发性 并发性高，多人同时请求，速度快、效率高。innodb锁机制：行锁，每次只锁住一条记录信息。 myisam , innodb 的取舍 myisam： 写入数据非常快，适合使用场合dedecms/phpcms/discuz/微博系统等写入、读取操作多的系统。 innodb： 适合业务逻辑比较强的系统，修改 操作较多的，例如ecshop、crm、办公系统、商城系统 myisam： 类型不支持事务处理等高级处理，而InnoDB类型支持. myisam： 类型的表强调的是性能，其执行数度比InnoDB类型更快. myisam： 支持表锁，InnoDB支持行锁。 innodb： 不支持FULLTEXT类型的索引. innodb： 中不保存表的具体行数，执行select count(*) from table时，InnoDB要扫描一整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可. memory Memory使用哈希索引，所以数据的存取速度非常快。 内存存储引擎 特点：内部数据都运行在内存中，可以应用于临时表中在需要快速查找引用和其他类似数据的环境下，数据存储也在内存中，速度非常快，临时存储一些信息 缺点：服务器如果断电，就会清空该存储引擎的全部数据 存储引擎的对比 特点 MyISAM Memory InnoDB 存储限制 没有 有 64TB 事务安全 MyISAM 支持 锁机制 表锁 表锁 行锁 B树索引 支持 支持 支持 哈希索引 支持 支持 全文索引 支持 集群索引 支持外键 数据可压缩 支持 空间使用 低 N/A 高 内存使用 低 中等 高 批量插入的速度 高 高 低 支持外键 支持 三范式设置索引1234alter table student5 add primary key (id);alter table student5 add unique key (name);alter table student5 add key (height);alter table student5 add fulltext key (introduce); 删除索引 语法：alter table 表名 drop key 索引名称; //[非主键]索引删除(唯一/普通/全文/复合)alter table 表名 drop primary key; //[主键]索引删除 注意：删除主键索引，必须先去除auto_increment属性 使用以下命令可查看是否开启单独存储数据与索引文件： * show variables like &apos;%innodb_file_per%&apos;; 可以修改配置，改变innodb数据表的数据、索引文件的存储方式： * set global innodb_file_per_table=1/0; InnodB数据表数据、索引合并文件分为两种情况： * 每个数据表都有自己的数据、索引合并文件 * 数据库中全部的数据表共享一个数据、索引合并文件]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 优化 (二)]]></title>
    <url>%2F2019%2F04%2F22%2F2019-04-22-Mysql%20%E4%BC%98%E5%8C%96%20(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[优化的方面 索引相关 分表设计 架构设计 慢查询日志收集 其他优化 Index 它是物理存在的 规则字段独立原则name (对)name + 2 (错)左原则like ‘bill%’ (对)like ‘%bill’ (错)复合索引不能直接使用第2个字段or 原则左右都有索引，会合并索引一起使用一边有索引、一边没有索引，导致整体都没得索引使用 设计依据 被频繁使用的字段设置索引 * 字段被频繁用在where和order等条件里边。 * 数据表创建完毕，要预估那些字段被经常使用，就给其创建索引 执行时间长的sql语句考虑设计索引 * 可以利用”慢查询日志”收集这样的sql语句并优化设计索引 * slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。 * long_query_time: 什么样的SQL才会记录到慢查询日志里面呢？ 这个是由参数long_query_time控制 逻辑非常重要的sql语句考虑设计索引 * 例如商城系统里边，会员给自己账户充值就比较重要 * 还有会员下订单购物，进行付款的时候也比较重要。 字段内容足够花样化，适合创建索引 * 反面教材，性别不能设计索引(内容的取值非常少) 前缀索引 什么是前缀索引： 如果一个字段内容的前边的n位信息已经足够标识当前的字段内容，就可以把字段的前n位获得出来并创建索引，通过字段内容前n位创建的索引就称为“前缀索引”。语法： alter table 表名 add key (字段(前n 位 位数)); 123// 测试，取前几位，可以获取索引alter table emp add key(password(3));select count(distinct(substring())) from emp; substring(字段,开始位置,长度n) 截取字段内容，字段下标从1开始 全文索引 把字段中的一些关键字单词出来制作索引 123456789101112131415CREATE TABLE articles ( id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, title VARCHAR(200), body TEXT)engine=myisam charset utf8;INSERT INTO articles (title,body) VALUES (&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;), (&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;), (&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;), (&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;), (&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;), (&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);alter table articles add fulltext key (body); 全文索引会解决like模糊查找不用索引的问题： select * from 表名 like ‘%内容%’; //不会使用索引 以上模糊查找如果必须使用索引，就可以使用全文索引 select * from 表名 where 字段 like ‘%内容%’; //不会用到全文索引 select * from 表名 where match(字段) against(内容) //会用到全文索引 全文索引注意 字段类型必须为varchar/char/text类型 mysql 5.6.4之前只有Myisam支持，5.6.4之后则Myisam和innodb都支持。 mysql中的全文索引目前只支持英文(不支持中文)，如果需要支持中文可以使用sphinx 生产活动中mysql的全文索引不常使用，sphinx常使用 mysql全文索引会自作聪明，对关键字的收录有自己的考虑(不是全部关键字都给收录)。 例如生活常用单词、频繁使用单词都不给创建索引(比如 for when where run you等等) 索引结构 索引就是数据结构， 数据以一定的结构组织起来，内部嵌入算法，算法可以保证数据被快速获取。 数据结构：数据以一种规律的、规则的方式组织在一起。(例如0-9顺序排列数字、a-z顺序排列字母等) 主要讨论两种：Myisam 和 Innodb..Mysql的索引数据结构都是B+tree结构(除此还有B-tree、二叉树等结构) MySQL 聚簇索引&amp;&amp;二级索引&amp;&amp;辅助索引mysql中每个表都有一个聚簇索引（clustered index ），除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。 以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。如果您的表上定义有主键，该主键索引是聚集索引。如果你不定义为您的表的主键时，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚集索引。如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。 MySQL 回表 二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。 explain explain select id from hotel where id = 61\G id: 自动分配一个唯一的标识符select_type: SELECT 查询的类型table: 查询的是哪个表partitions: 匹配的分区type: join 类型possible_keys: 此次查询中可能选用的索引key: 此次查询中确切使用到的索引.指出MySQL能使用哪个索引在该表中找到行key_len: 4 // 显示MySQL决定使用的键长度。如果键是NULL,则长度为NULLref: 哪个字段或常数与 key 一起被使用rows: 显示此查询一共扫描了多少行. 这个是一个估计值.原则上 rows 越少越好.filtered: 表示此查询条件所过滤的数据的百分比Extra: 额外的信息 select_typeSIMPLE:简单SELECT(不使用UNION或子查询)PRIMARY:最外面的SELECTUNION:UNION中的第二个或后面的SELECT语句DEPENDENT UNION:UNION中的第二个或后面的SELECT语句,取决于外面的查询UNION RESULT:UNION 的结果SUBQUERY:子查询中的第一个SELECTDEPENDENT SUBQUERY:子查询中的第一个SELECT,取决于外面的查询DERIVED:导出表的SELECT(FROM子句的子查询) typesystem:表仅有一行(=系统表)。这是const联接类型的一个特例。const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。ref_or_null:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。index_merge:该联接类型表示使用了索引合并优化方法。unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)range:只检索给定范围的行,使用一个索引来选择行。index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。ALL:对于每个来自于先前的表的行组合,进行完整的表扫描。 通常来说, 不同的 type 类型的性能关系如下:ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; systemALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了. ExtraDistinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大. 我们的索引是 KEY user_product_detail_index (user_id, product_name, productor) 但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了 需要优化的：Using filesort，Using temporary 分表设计 一个数据表里边存储的记录信息太多了，例如记录的条数达到千万条信息，该数据表的活性就大大降低，运行速度、效率大打折扣，影响mysql数据库的整体性能，因此要给数据表进行分表设计，使得每个表存储少量的数据。 逻辑分表 注意：分表字段必须是主键 或 主键的一部分(复合主键索引的第二个字段也可以) range 分表 [范围方式] 可以将一个表通过年份划分成三个分区，80年代(1980)的数据90年代(1990)的数据，以此类推 语法： partition by range(表达式 | 字段)( partition 名称1 values less than (常量整数值), partition 名称2 values less than (常量整数值), … …) 123456789101112CREATE TABLE `bill` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;id&apos;, `create_at` int(11) NOT NULL COMMENT &apos;记录时间&apos;, `comid` int(11) NOT NULL COMMENT &apos;企业id&apos;, PRIMARY KEY (`id`), KEY `comid` (`comid`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=328830 DEFAULT CHARSET=utf8 COMMENT=&apos;账单记录表&apos;partition by range (id)( partition id1 values less than (500), partition id2 values less than (1000), partition id3 values less than MAXVALUE // 最大值) range 添加分表 语法：alter table 表名 add partition( partition 名称1 values less than (常量整数值), … …) list 分表 [范围方式] 语法：partition by list(month(pubdate))( partition 名称 values in (列表范围), … …) list 添加分表 语法：alter table 表名 add partition( partition 名称 values in (列表范围), … …) range, list 删除分表 语法：alter table 表名 drop partition 分区名称 key 分表 [求余方式] 语法：partition by key(条件字段) partitions 数量; hash 分表 [求余方式] partition by hash (表达式|字段) partitions 数量 key, hash 添加分表 alter table 表名 add partition partitions 数量; key, hash 删除分表 alter table 表名 coalesce partition 数量 物理分表垂直分表慢查询日志收集slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.logslow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.loglong_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。 12show variables like &apos;%slow_query_log%&apos;;set global slow_query_log=1; 使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）修改my.cnf文件，增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器 日志分析工具mysqldumpslowmysqldumpslow --help -s, 是表示按照何种方式排序 c: 访问计数 l: 锁定时间 r: 返回记录 t: 查询时间 al:平均锁定时间 ar:平均返回记录数 at:平均查询时间 -t, 是top n的意思，即为返回前面多少条的数据；-g, 后边可以写一个正则匹配模式，大小写不敏感的； 比如:得到返回记录集最多的10个SQL。mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log 得到访问次数最多的10个SQLmysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log 得到按照时间排序的前10条里面含有左连接的查询语句。mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Go 语言实现 二叉查找树。 日常笔记。原文 定义二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；任意节点的左、右子树也分别为二叉查找树。没有键值相等的节点（no duplicate nodes）。 实现结构体1234567891011// 二叉查找树type Tree struct &#123; Root *Node&#125;// 结点type Node struct &#123; Value int Left *Node Right *Node Parent *Node&#125; 添加一个结点123456789101112131415161718192021222324252627func (this *Tree) Insert(v int) &#123; n := new(Node) n.Value = v if this.Root == nil &#123; this.Root = n return &#125; cur := this.Root for &#123; n.Parent = cur if v &lt; cur.Value &#123; if cur.Left == nil &#123; cur.Left = n break &#125; else &#123; cur = cur.Left &#125; &#125; else &#123; if cur.Right == nil &#123; cur.Right = n break &#125; else &#123; cur = cur.Right &#125; &#125; &#125;&#125; 遍历树1234567891011func (this *Tree) Select() &#123; var mapSearch func(n *Node) mapSearch = func(n *Node)&#123; if n != nil &#123; mapSearch(n.Left) fmt.Println(n.Value) mapSearch(n.Right) &#125; &#125; mapSearch(this.Root)&#125; 查找一个结点123456789101112131415161718func (this *Tree) Search(v int) *Node&#123; cur := this.Root for &#123; if v &lt; cur.Value &#123; cur = cur.Left if cur == nil &#123; return nil &#125; &#125; else if v &gt; cur.Value &#123; cur = cur.Right if cur == nil &#123; return nil &#125; &#125; else &#123; return cur &#125; &#125;&#125; 最小结点12345678910func (this *Tree) Min() *Node&#123; cur := this.Root for &#123; if cur.Left != nil &#123; cur = cur.Left &#125; else &#123; return cur &#125; &#125;&#125; 最大结点12345678910func (this *Tree) Max() *Node&#123; cur := this.Root for &#123; if cur.Right != nil &#123; cur = cur.Right &#125; else &#123; return cur &#125; &#125;&#125; 删除一个结点12345678910111213141516171819202122232425262728293031323334353637383940414243444546func (this *Tree) Delete(v int) &#123; fmt.Printf(&quot;del: %d\n&quot;,v) var ( mapDel func (n *Node) cur = this.Search(v) ) mapDel = func (cur *Node) &#123; if cur == nil &#123; return &#125; if cur.Left == nil &amp;&amp; cur.Right == nil &#123; if cur.Parent.Left == cur &#123; cur.Parent.Left = nil &#125; else &#123; cur.Parent.Right = nil &#125; &#125; else if cur.Left == nil &amp;&amp; cur.Right != nil &#123; cur.Right.Parent = cur.Parent if cur.Parent.Left == cur &#123; cur.Parent.Left = cur.Right &#125; else &#123; cur.Parent.Right = cur.Right &#125; &#125; else if cur.Left != nil &amp;&amp; cur.Right == nil &#123; cur.Left.Parent = cur.Parent if cur.Parent.Left == cur &#123; cur.Parent.Left = cur.Left &#125; else &#123; cur.Parent.Right = cur.Left &#125; &#125; else &#123; fmt.Println(&quot;both&quot;) curs := cur.Right for &#123; if curs.Left != nil &#123; curs = curs.Left &#125; else &#123; break &#125; &#125; cur.Value = curs.Value mapDel(curs) &#125; &#125; mapDel(cur)&#125; 1234567891011121314151617181920212223func main() &#123; var t Tree t.Insert(100) t.Insert(120) t.Insert(80) t.Insert(70) t.Insert(90) t.Insert(85) t.Insert(95) t.Insert(110) t.Select() t.Delete(80) t.Select() fmt.Println(&quot;---------------&quot;) val := t.Search(110) fmt.Println(val) fmt.Println(t.Min()) fmt.Println(t.Root.Value) fmt.Println(t.Root.Left.Value) fmt.Println(t.Root.Right.Value) t.Edit(80,125) t.Select()&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2019%2F03%2F18%2F2019-03-18-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用正则汇总。 PHP preg_match ( string $pattern , string $subject ) : int 搜索subject与pattern给定的正则表达式的一个匹配. 密码规范包括8 - 16 大小写，符号数字1/^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])[A-Za-z0-9!@#$%*()_+^&amp;]&#123;8,16&#125;$/ 手机号1/^1[3|4|5|7|8][0-9]\d&#123;4,8&#125;$/ 与 pathinfo 功能类似1%^(.*?)[\\\\/]*(([^/\\\\]*?)(\.([^\.\\\\/]+?)|))[\\\\/\.]*$%im 与 parse_url 功能类似12 javaScript12345var reg = /.../reg.test(&apos;18332566840&apos;) //返回 true falsestr.match(reg) //返回 null]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>javaScript</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 数据类型]]></title>
    <url>%2F2019%2F03%2F18%2F2019-03-18-PHP%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[PHP 支持 9 种原始数据类型。四种标量类型：boolean（布尔型）integer（整型）float（浮点型，也称作 double)string（字符串）三种复合类型：array（数组）object（对象）callable（可调用）最后是两种特殊类型：resource（资源）NULL（无类型）伪类型：mixed（混合类型）number（数字类型）callback（回调类型，又称为 callable）array|object（数组 | 对象类型）void （无类型） 简介变量的类型通常不是由程序员设定的，是由 PHP 根据该变量使用的上下文在运行时决定的。 boolean（布尔型）要明确地将一个值转换成 boolean，用 (bool) 或者 (boolean) 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 boolean 参数时，该值会被自动转换。 当转换为 boolean 时，以下值被认为是 FALSE： 1234567布尔值 FALSE 本身整型值 0（零）浮点型值 0.0（零）空字符串，以及字符串 &quot;0&quot;不包括任何元素的数组特殊类型 NULL（包括尚未赋值的变量）从空标记生成的 SimpleXML 对象 (没有验证过 ...) 例子12345var_dump(0 == &apos;all&apos;); // truevar_dump((int)&apos;all&apos;); // int(0)var_dump(0 == (bool)&apos;all&apos;); // falsevar_dump((int)true); // int(1) integer（整型）整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。用 (int) 或 (integer) 强制转换。 123var_dump(PHP_INT_SIZE); // 结果：int(4) // 占用4个字节var_dump(PHP_INT_NAX); // 结果：int(2147483647) // php中int不支持无符号var_dump(PHP_INT_MIN); // 结果：int(-2147483648) 例子123echo (int) ( 1.6); // 显示 1 // 当从浮点数转换成整数时，将向下取整。echo (int)@NaN . PHP_EOL; // int(0) // PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。echo (int) ( (0.1+0.7) * 10 ); // 显示 7 // 浮点数强制转换 integer，会出现不可预料的错误 待验证：在32位平台上int占4个字节，在64位平台上int占8个字节,16位平台是则分配2个字节整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。64 位平台下的最大值通常是大约 9E18，除了 Windows 下 PHP 7 以前的版本，总是 32 位的。 PHP 不支持无符号的 integer。Integer 值的字长可以用常量 PHP_INT_SIZE来表示，自 PHP 4.4.0 和 PHP 5.0.5后，最大值可以用常量 PHP_INT_MAX 来表示，最小值可以在 PHP 7.0.0 及以后的版本中用常量 PHP_INT_MIN 表示。 float（浮点型，也称作 double)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F03%2F18%2F2019-03-18-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用正则汇总。 修饰符i 如果在修饰符中加上”i”，则正则将会取消大小写敏感性，即”a”和”A” 是一样的。m 默认的正则开始”^”和结束”$”只是对于正则字符串如果在修饰符中加上”m”，那么开始和结束将会指字符串的每一行：每一行的开头就是”^”，结尾就是”$”。o 表达式只执行一次。s 如果在修饰符中加入”s”，那么默认的”.”代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！x 如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。e 替换字符串作为表达式 更多正则表达式规则. 匹配除换行符以外的所有字符x? 匹配 0 次或一次 x 字符串x 匹配 0 次或多次 x 字符串,但匹配可能的最少次数x+ 匹配 1 次或多次 x 字符串,但匹配可能的最少次数. 匹配 0 次或多次的任何字符.+ 匹配 1 次或多次的任何字符{m} 匹配刚好是 m 个 的指定字符串{m,n} 匹配在 m个 以上 n个 以下 的指定字符串{m,} 匹配 m个 以上 的指定字符串[] 匹配符合 [] 内的字符[^] 匹配不符合 [] 内的字符[0-9] 匹配所有数字字符[a-z] 匹配所有小写字母字符[^0-9] 匹配所有非数字字符[^a-z] 匹配所有非小写字母字符^ 匹配字符开头的字符$ 匹配字符结尾的字符\d 匹配一个数字的字符,和 [0-9] 语法一样\d+ 匹配多个数字字符串,和 [0-9]+ 语法一样\D 非数字,其他同 \d\D+ 非数字,其他同 \d+\w 英文字母或数字的字符串,和 [a-zA-Z0-9_] 语法一样\w+ 和 [a-zA-Z0-9_]+ 语法一样\W 非英文字母或数字的字符串,和 [^a-zA-Z0-9_] 语法一样\W+ 和 [^a-zA-Z0-9_]+ 语法一样\s 空格,和 [\n\t\r\f] 语法一样\s+ 和 [\n\t\r\f]+ 一样\S 非空格,和 [^\n\t\r\f] 语法一样\S+ 和 [^\n\t\r\f]+ 语法一样\b 匹配以英文字母,数字为边界的字符串\B 匹配不以英文字母,数值为边界的字符串a|b|c 匹配符合a字符 或是b字符 或是c字符 的字符串abc 匹配含有 abc 的字符串 (pattern) () 这个符号会记住所找寻到的字符串,是一个很实用的语法.第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量,第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量,以此类推下去./pattern/i i 这个参数表示忽略英文大小写,也就是在匹配字符串的时候,不考虑英文的大小写问题. \ 如果要在 pattern 模式中找寻一个特殊字符,如 “*”,则要在这个字符前加上 \ 符号,这样才会让特殊字符失效 更多修饰符A (PCRE_ANCHORED)如果设置了这个修饰符，模式被强制为”锚定”模式，也就是说约束匹配使其仅从 目标字符串的开始位置搜索。这个效果同样可以使用适当的模式构造出来，并且 这也是 perl 种实现这种模式的唯一途径。D (PCRE_DOLLAR_ENDONLY)如果这个修饰符被设置，模式中的元字符美元符号仅仅匹配目标字符串的末尾。如果这个修饰符 没有设置，当字符串以一个换行符结尾时， 美元符号还会匹配该换行符(但不会匹配之前的任何换行符)。 如果设置了修饰符m，这个修饰符被忽略. 在 perl 中没有与此修饰符等同的修饰符。S当一个模式需要多次使用的时候，为了得到匹配速度的提升，值得花费一些时间 对其进行一些额外的分析。如果设置了这个修饰符，这个额外的分析就会执行。当前， 这种对一个模式的分析仅仅适用于非锚定模式的匹配(即没有单独的固定开始字符)。U (PCRE_UNGREEDY)这个修饰符逆转了量词的”贪婪”模式。 使量词默认为非贪婪的，通过量词后紧跟? 的方式可以使其成为贪婪的。这和 perl 是不兼容的。 它同样可以使用 模式内修饰符设置 (?U)进行设置， 或者在量词后以问号标记其非贪婪(比如.*?)。Note: 在非贪婪模式，通常不能匹配超过 pcre.backtrack_limit 的字符。 X (PCRE_EXTRA)这个修饰符打开了 PCRE 与 perl 不兼容的附件功能。模式中的任意反斜线后就 ingen 一个 没有特殊含义的字符都会导致一个错误，以此保留这些字符以保证向后兼容性。 默认情况下，在 perl 中，反斜线紧跟一个没有特殊含义的字符被认为是该字符的原文。 当前没有其他特性由这个修饰符控制。J (PCRE_INFO_JCHANGED)内部选项设置(?J)修改本地的PCRE_DUPNAMES选项。允许子组重名， (译注：只能通过内部选项设置，外部的 /J 设置会产生错误。)u (PCRE_UTF8)此修正符打开一个与 perl 不兼容的附加功能。 模式和目标字符串都被认为是 utf-8 的。 无效的目标字符串会导致 preg_* 函数什么都匹配不到； 无效的模式字符串会导致 E_WARNING 级别的错误。 PHP 5.3.4 后，5字节和6字节的 UTF-8 字符序列被考虑为无效（resp. PCRE 7.3 2007-08-28）。 以前就被认为是无效的 UTF-8。]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>javaScript</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-javaScript-RSA 非对称加密]]></title>
    <url>%2F2019%2F03%2F15%2F2019-04-09-PHP-javaScript-RSA%20%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[基于 jsencrypt.js 之 javaScript 加密，PHP解密。 (应用于登录注册)。前端后台数据交互需要进行加密之后传输使用，以保证系统数据的安全。非对称加密速度慢，所以只能加密较小的数据。可以在AES 基础上进行RSA 加密(将数据 AES 加密，在用RSA 加密 AES的密钥)。 JavaScript1234567891011121314151617181920212223242526272829&lt;script src=&apos;&#123;&#123;asset(&quot;js/jsencrypt.min.js&quot;)&#125;&#125;&apos;&gt;&lt;/script&gt;&lt;script&gt; var username = &apos;1112223&apos;, password = &apos;123456&apos;; function rsa(text, key) &#123; var encrypt = new JSEncrypt(); encrypt.setPublicKey(key); var encrypted = encrypt.encrypt(text); return encrypted; &#125; $.ajax(&#123; url:&apos;http://www.you.com/test/rsa/public&apos;, // 发送请求获取 公钥 type:&apos;post&apos;, dataType:&apos;json&apos;, success:function(data) &#123; // data 返回的 public key var en = rsa(password, data.result); $.ajax(&#123; url:&apos;http://www.you.com/test/rsa/doLogin&apos;, type:&apos;post&apos;, dataType:&apos;json&apos;, data:&#123;password:en&#125;, success:function(data) &#123; console.log(data); &#125; &#125;); &#125; &#125;);&lt;/script&gt; PHP 确认是否有openssl 扩展 12345 $privKey = openssl_pkey_get_private($private_key);$encrypted = base64_decode($encrypted); // jsencrypt, 默认使用base64 加密，所以需要解密// Decrypt the data using the private key and store the results in $decryptedopenssl_private_decrypt($encrypted, $decrypted, $privKey); // $encrypted 需要解密的文本return $decrypted; 生成私钥、公钥12345678910111213$config = array( &quot;digest_alg&quot; =&gt; &quot;sha512&quot;, &quot;private_key_bits&quot; =&gt; 4096, &quot;private_key_type&quot; =&gt; OPENSSL_KEYTYPE_RSA, );$res = openssl_pkey_new($config);openssl_pkey_export($res, $privKey);$pubKey = openssl_pkey_get_details($res);$pubKey = $pubKey[&quot;key&quot;];// 将私钥 $privKey , 和公钥 $pubKey 保存起来file_put_contents(&apos;./cert_public.key&apos;, $pubKey);file_put_contents(&apos;./cert_private.pem&apos;, $privKey);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>javaScript</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-javaScript-AES 对称加密]]></title>
    <url>%2F2019%2F03%2F15%2F2019-03-15-php-javascript-AES%20%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[基于 Crypto.js 之 javaScript 加密，PHP解密。 (应用于登录注册)。前端后台数据交互需要进行加密之后传输使用，以保证系统数据的安全。 javaScript1234567891011121314151617&lt;script src=&quot;../node_modules/_crypto-js@3.1.9-1@crypto-js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var password = &apos;123456&apos;; var aes_password = encrypt(password); // aes_password 加密后的数据 function encrypt(text)&#123; var key = CryptoJS.enc.Latin1.parse(&apos;AQSWDEFRGT@#$%^&amp;&apos;); //为了避免补位，直接用16位的秘钥 var iv = CryptoJS.enc.Latin1.parse(&apos;AQSWDE@#$%^&amp;FRGT&apos;); //16位初始向量 var encrypted = CryptoJS.AES.encrypt(text, key, &#123; iv: iv, mode:CryptoJS.mode.CBC, padding:CryptoJS.pad.ZeroPadding &#125;); return encrypted.toString(); &#125;&lt;/script&gt; PHP123$key = &quot;AQSWDEFRGT@#$%^&amp;&quot;;$iv = &quot;AQSWDE@#$%^&amp;FRGT&quot;;$password = openssl_decrypt($password, &apos;aes-128-cbc&apos;, $key, OPENSSL_ZERO_PADDING , $iv); 如果想做安全一点就是前端和后台是用同一个算法来生成key,使其不是唯一。然后不停的交换秘钥，这种情况下用户只有分析js秘钥生成算法和密文信息才有可能解密出来。 Crypto.js]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>javaScript</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建-LNMP-环境]]></title>
    <url>%2F2018%2F06%2F20%2F2018-06-20-%E6%90%AD%E5%BB%BA-LNMP-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[LNMP : linux + nginx1 + mysql5 + php7 依赖文件 我们后边要安装的php、apache、mysql等相关的软件，这些软件都是通过C语言或C++语言编写的，因此需要安装gcc和gcc-c++编译器。 zlib软件是后续其他软件的依赖软件，有其他软件有代码优化压缩的作用。 安装 Nginx下载 nginx 官网：http://nginx.org 下载：http://nginx.org/download/nginx-1.12.2.tar.gz 依赖文件(解压, 安装)1[root@localhost ~] yum -y install pcre-devel pcre 是线上产品 pcre-devel(develop)是开发调试版本产品，里边有一些功能是线上产品不不具备 pcre： 包括 perl 兼容的正则表达式库 nginx install123[root@localhost ~] tar zxf nginx-1.12.2.tar.gz[root@localhost ~] ./configure --prefix=/usr/local/nginx --with-http_ssl_module[root@localhost ~] make &amp;&amp; make install –with-http_ssl_module //配置https安全型协议支持 nginx 目录 conf：配置文件目录 html：网站默认请求目录，与apache的htdocs目录作用一致 logs：记录日志文件目录 sbin：执行程序文件目录，里边有一个nginx执行程序文件，负责控制nginx服务 控制服务在/usr/local/nginx/sbin目录里边进行服务操控 123[root@localhost ~] ./nginx 开启apache服务[root@localhost ~] ./nginx -s stop 关闭apache服务[root@localhost ~] ./nginx -s reload 重启apache服务 nginx.conf 配置防火墙为了使得外部用户浏览器可以访问到nginx服务效果，还需要把linux系统本身的防火墙给予关闭掉 1[root@localhost ~] setup 安装 PHP apache+PHP：php是apache内部的功能模块，它们是包含与被包含的关系 nginx+PHP：php作为独立服务运行，与nginx地位平等 安装 依赖php install123[root@localhost ~] tar zxf php-7.0.25.tar.gz[root@localhost ~] ./configure --prefix=/usr/local/php7.0 --with-config-file-path=/usr/local/php7.0/etc --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-jpeg-dir --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib --enable-bcmath --enable-libxml --enable-inline-optimization --enable-gd-native-ttf --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-xml --enable-zip --enable-fpm[root@localhost ~] make &amp;&amp; make install 现在我们给php做configure配置，和 LAMP 不同的是： 去除apache参数 增加enable-fpm，作用是使得php作为独立服务运行 增加–with-config-file-path参数，设置php.ini配置文件存储目录 php 目录 bin： 运行目录，里边有php脚本文件，可以运行php程序文件。还有用于添加扩展的phpize和php-config等文件 etc： 配置文件目录，马上要把php.ini创建在该目录 include： 包含目录，其中include/php/ext是php扩展功能目录，例如gd、mysqli、libxml、pcre、pdo等都安装在该目录 lib： library资源库目录，其中lib/php/extensions/no-debug-non-zts-20151012目录是用于存储后期给php增加相关功能模块，例如redis.so、memcache.so等都会存储在该目录，并且在php.ini文件中可以直接引入 sbin： 运行目录，里边的php-fpm是负责管理php服务的 var： variable变化目录，该目录中有run和log目录，都是存储php运行过程中产生的日志或临时文件的 参数 详解 –with-apxs2=/usr/local/apache2/bin/apxs –&gt; 上边的指令会在安装php的时候就自动生成php模块，名称为libphp7so，并且该模块会生成到apache的对应模块目录(/usr/local/apache2/modules/)里边，然后还会自动去修改httpd.conf文件，使得引入该libphp7.so的模块 –with-curl –&gt; 打开curl的支持，使得php可以访问其他网站的网址并获得对应的内容，是爬虫技术范畴，file_get_contents(“http://xxx”); –with-freetype-dir –&gt; 字体库支持 –with-gd –&gt; 画图技术支持，我们并不需要主动安装gd库，该gd库已经被集成在php内部(如下图)了，随着php安装gd库也会被自动安装好 –with-gettext –&gt; 支持开发多语言系统 –with-iconv-dir –&gt; iconv函数库能够完成各种字符集间的转换 –with-kerberos –&gt; kerberos支持 –with-jpeg-dir –&gt; jpeg图片格式支持 –with-libxml-dir –&gt; libxml2库的支持 –with-mysqli –&gt; Mysqli数据库的支持 –with-openssl –&gt; openssl的支持，加密传输时用到的,类似这样的协议https://xx就需要openssl的技术支持 –with-pcre-regex –&gt; 正则表达式支持 –with-pdo-mysql –&gt; pdo-mysql支持 –with-pear –&gt; pear是PHP的扩展和应用程序库，包含了很多有用的类 –with-png-dir –&gt; png图片格式支持 –with-xmlrpc –&gt; xml相关的扩展库支持 –with-xsl –&gt; 打开XSLT 文件支持，扩展了libXML2库 ，需要libxslt软件 –with-zlib –&gt; zlib压缩库支持 –enable-bcmath –&gt; 图片大小调整技术支持 –enable-libxml –&gt; xml支持 –enable-inline-optimization –&gt; 优化线程，给php整体做性能优化处理 –enable-gd-native-ttf –&gt; 画图字体库支持，支持TrueType字符串函数库 –enable-mbregex –&gt; 正则表达式支持 –enable-mbstring –&gt; mb宽字节函数库支持 –enable-opcache –&gt; 缓存支持 –enable-pcntl –&gt; pcntl扩展可以支持php的多线程操作 –enable-shmop –&gt; shmop是一个易于使用的功能集，允许PHP读，写，创建和删除UNIX共享内存段 –enable-sysvsem –&gt; 作用同上 –enable-soap –&gt; SOAP 的全称为简单对象访问协议 (Simple Object Access Protocol)。它是一种基于 XML 的，可扩展的通信协议。SOAP 提供了一种标准，使得运行在不同平台上并使用不同的编程语言编写的应用程序可以互相进行通信 –enable-sockets –&gt; sockets 支持 –enable-xml –&gt; xml支持 –enable-zip –&gt; php支持对zip压缩包处理 (上述有一些配置参数没有设置依赖软件的路径名，其会到系统默认位置找到对应的软件，如果依赖软件没有安装到系统默认位置，则需要通过完整路径名显示设置好。还有一些配置参数本身就是“是或否”的意思，则不需要设置依赖路径名) 制作php.ini文件在php解压目录里边把php.ini-development 复制到/usr/local/php7.0/lib/php.ini 1[root@localhost ~] cp php.ini-development /usr/local/php7.0/lib/php.ini 服务配置文件php是作为独立服务与nginx进行合作工作的，现在需要给“php服务”创建配置文件 创建主配置文件 把php-fpm.conf.default文件复制到当前目录并改名字为php-fpm.conf，这个文件就是“php服务”的主配置文件 123[root@localhost ~] pwd/usr/local/php7.0/etc[root@localhost ~] cp php-fpm.conf.default php-fpm.conf 辅助配置文件 /usr/local/php7.0/etc/php-fpm.d/www.conf.default 辅助配置文件在“辅助配置文件”中有“php服务”运行的详细参数(例如服务的端口号码9000等)，只有被主配置文件引入后php服务才可以正常运行代表对辅助配置文件进行引入，但是辅助配置文件需要改名字为.conf后缀的 123[root@localhost ~] pwd/usr/local/php7.0/etc/php-fpm.d[root@localhost ~] cp www.conf.default www.conf 服务控制 php-fpm 启动 killall php-fpm 关闭 nginx与php结合安装 MySQL卸载旧的 MySQL, 同apache下载mysql组件 官网：https://www.mysql.com 下载地址：https://dev.mysql.com/downloads/mysql/ MySQL install1234[root ~] rpm -ivh mysql-community-common-5.7.20-1.el6.i686.rpm[root ~] rpm -ivh mysql-community-libs-5.7.20-1.el6.i686.rpm[root ~] rpm -ivh mysql-community-client-5.7.20-1.el6.i686.rpm[root ~] rpm -ivh mysql-community-server-5.7.20-1.el6.i686.rpm 以上组件的安装是有自上而下的顺序要求，因为它们彼此有依赖关系。 服务控制1[root@localhost ~] service mysqld start[/stop/restart] 查看默认的root帐号密码1[root@localhost ~] grep &quot;root@localhost&quot; /var/log/mysqld.log 修改root帐号密码1mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 设置字符集在配置文件最后添加以下内容： 连接mysql时的字符集设置为utf8mb4init-connect=’SET NAMES utf8mb4’ 默认存储引擎为INNODBdefault-storage-engine=INNODB 服务器端字符集设置为utf8mb4character-set-server=utf8mb4[mysql] mysql本身字符集设置为utf8mb4default-character-set = utf8mb4[client] 客户端操作mysql时字符集设置为utf8mb4default-character-set = utf8mb4 工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建-LAMP-环境]]></title>
    <url>%2F2018%2F05%2F10%2F2018-05-10-%E6%90%AD%E5%BB%BA-LAMP-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[LAMP : linux + apache2 + mysql5 + php7 删除旧的 apache 把操作系统默认安装的apache给卸载掉，避免与我们要安装的有冲突 1[root@localhost ~] yum list installed | grep httpd 卸载与httpd有关系的软件 12[root@localhost ~] yum -y remove httpd[root@localhost ~] yum -y remove httpd-tools 再整个系统中找与httpd有关系的文件或目录 1[root@localhost ~] find / -name httpd 删除与httpd有关系的文件 12[root@localhost ~] rm -rf /etc/httpd[root@localhost ~] rm -rf /usr/lib/httpd 依赖文件 我们后边要安装的php、apache、mysql等相关的软件，这些软件都是通过C语言或C++语言编写的，因此需要安装gcc和gcc-c++编译器。 zlib软件是后续其他软件的依赖软件，有其他软件有代码优化压缩的作用。 安装 Apache依赖文件(解压, 安装)123456[root@localhost ~] tar zxf apr-1.5.2.tar.gz [root@localhost ~] ./configure --prefix=/usr/local/apr[root@localhost ~] tar zxf apr-util-1.5.4.tar.gz[root@localhost ~] ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr[root@localhost ~] tar zxf pcre-8.40.tar.gz[root@localhost ~] ./configure --prefix=/usr/local/pcre apache install123[root@localhost ~] tar zxf httpd-2.4.29.tar.gz[root@localhost ~] ./configure --prefix=/usr/local/apache2 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcre --with-z=/usr/local/zlib --enable-so --enable-rewrite[root@localhost ~] make &amp;&amp; make install –enable-so 让apache激活并可以识别使用so后缀的功能模块 –enable-rewrite 开启重写模块(可以修改地址栏信息，例如隐藏index.php入口文件) 控制服务在/usr/local/apache2/bin目录里边进行服务操控 123[root@localhost ~] ./apachectl start 开启apache服务[root@localhost ~] ./apachectl stop 关闭apache服务[root@localhost ~] ./apachectl restart 重启apache服务 防火墙为了使得外部用户浏览器可以访问到apache服务效果，还需要把linux系统本身的防火墙给予关闭掉 1[root@localhost ~] setup 安装 PHP安装 依赖12345678910111213[root@localhost ~] yum -y install libxml2-develxml库依赖支持[root@localhost ~] yum -y install openssl-developenssl： 支持安全传输协议https[root@localhost ~] yum -y install libcurl-develcurl是服务器彼此间调用的接口，常用于爬虫技术[root@localhost ~] yum -y install libjpeg-turbo-devel[root@localhost ~] yum -y install libpng-develpng图片格式支持[root@localhost ~] yum -y install freetype-devel画图字体库支持[root@localhost ~] yum -y install libxslt-devel打开XSLT 文件支持，扩展了libXML2库 php install12[root@localhost ~] tar zxf php-7.0.25.tar.gz[root@localhost ~] ./configure --prefix=/usr/local/php7.0 --with-apxs2=/usr/local/apache2/bin/apxs --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-jpeg-dir --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib --enable-bcmath --enable-libxml --enable-inline-optimization --enable-gd-native-ttf --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-xml --enable-zip 参数 详解 –with-apxs2=/usr/local/apache2/bin/apxs –&gt; 上边的指令会在安装php的时候就自动生成php模块，名称为libphp7so，并且该模块会生成到apache的对应模块目录(/usr/local/apache2/modules/)里边，然后还会自动去修改httpd.conf文件，使得引入该libphp7.so的模块 –with-curl –&gt; 打开curl的支持，使得php可以访问其他网站的网址并获得对应的内容，是爬虫技术范畴，file_get_contents(“http://xxx”); –with-freetype-dir –&gt; 字体库支持 –with-gd –&gt; 画图技术支持，我们并不需要主动安装gd库，该gd库已经被集成在php内部(如下图)了，随着php安装gd库也会被自动安装好 –with-gettext –&gt; 支持开发多语言系统 –with-iconv-dir –&gt; iconv函数库能够完成各种字符集间的转换 –with-kerberos –&gt; kerberos支持 –with-jpeg-dir –&gt; jpeg图片格式支持 –with-libxml-dir –&gt; libxml2库的支持 –with-mysqli –&gt; Mysqli数据库的支持 –with-openssl –&gt; openssl的支持，加密传输时用到的,类似这样的协议https://xx就需要openssl的技术支持 –with-pcre-regex –&gt; 正则表达式支持 –with-pdo-mysql –&gt; pdo-mysql支持 –with-pear –&gt; pear是PHP的扩展和应用程序库，包含了很多有用的类 –with-png-dir –&gt; png图片格式支持 –with-xmlrpc –&gt; xml相关的扩展库支持 –with-xsl –&gt; 打开XSLT 文件支持，扩展了libXML2库 ，需要libxslt软件 –with-zlib –&gt; zlib压缩库支持 –enable-bcmath –&gt; 图片大小调整技术支持 –enable-libxml –&gt; xml支持 –enable-inline-optimization –&gt; 优化线程，给php整体做性能优化处理 –enable-gd-native-ttf –&gt; 画图字体库支持，支持TrueType字符串函数库 –enable-mbregex –&gt; 正则表达式支持 –enable-mbstring –&gt; mb宽字节函数库支持 –enable-opcache –&gt; 缓存支持 –enable-pcntl –&gt; pcntl扩展可以支持php的多线程操作 –enable-shmop –&gt; shmop是一个易于使用的功能集，允许PHP读，写，创建和删除UNIX共享内存段 –enable-sysvsem –&gt; 作用同上 –enable-soap –&gt; SOAP 的全称为简单对象访问协议 (Simple Object Access Protocol)。它是一种基于 XML 的，可扩展的通信协议。SOAP 提供了一种标准，使得运行在不同平台上并使用不同的编程语言编写的应用程序可以互相进行通信 –enable-sockets –&gt; sockets 支持 –enable-xml –&gt; xml支持 –enable-zip –&gt; php支持对zip压缩包处理 (上述有一些配置参数没有设置依赖软件的路径名，其会到系统默认位置找到对应的软件，如果依赖软件没有安装到系统默认位置，则需要通过完整路径名显示设置好。还有一些配置参数本身就是“是或否”的意思，则不需要设置依赖路径名) 制作php.ini文件在php解压目录里边把php.ini-development 复制到/usr/local/php7.0/lib/php.ini 1[root@localhost ~] cp php.ini-development /usr/local/php7.0/lib/php.ini 安装 MySQL卸载旧的 MySQL, 同apache下载mysql组件 官网：https://www.mysql.com 下载地址：https://dev.mysql.com/downloads/mysql/ MySQL install1234[root ~] rpm -ivh mysql-community-common-5.7.20-1.el6.i686.rpm[root ~] rpm -ivh mysql-community-libs-5.7.20-1.el6.i686.rpm[root ~] rpm -ivh mysql-community-client-5.7.20-1.el6.i686.rpm[root ~] rpm -ivh mysql-community-server-5.7.20-1.el6.i686.rpm 以上组件的安装是有自上而下的顺序要求，因为它们彼此有依赖关系。 服务控制1[root@localhost ~] service mysqld start[/stop/restart] 查看默认的root帐号密码1[root@localhost ~] grep &quot;root@localhost&quot; /var/log/mysqld.log 修改root帐号密码1mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 设置字符集在配置文件最后添加以下内容： 连接mysql时的字符集设置为utf8mb4init-connect=’SET NAMES utf8mb4’ 默认存储引擎为INNODBdefault-storage-engine=INNODB 服务器端字符集设置为utf8mb4character-set-server=utf8mb4[mysql] mysql本身字符集设置为utf8mb4default-character-set = utf8mb4[client] 客户端操作mysql时字符集设置为utf8mb4default-character-set = utf8mb4 远程连接1.使用mysql -u root -p登录mysql 2.执行grant all privileges on . to ‘root‘@’%’ identified by ‘111111’; 3.flush privileges; 这时我们使用Navicat登录会发现无法连接，这是因为未开放3306端口的原因 4.开放3306端口 12345firewall-cmd --add-port=3306/tcp --permanentfirewall-cmd --add-port=3306/udp --permanentfirewall-cmd --reload 这时再通过Navicat发现连接成功。 工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>linux</tag>
        <tag>apache</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
